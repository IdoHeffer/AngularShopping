var assert = require('assert'),
  jwt = require('jwt-simple'),
  Middleware = require('../lib/index'),
  certs = require('./certs');

describe('jwt-middleware', function() {

  var accessToken;

  var mw = new Middleware({
    ttl: 3600,
    getKey: function(payload, cb) {
      if (payload.iss == 'alpha@adslot.com') cb(null, certs.alpha.public, {id: 1});
      else if (payload.iss == 'beta@adslot.com') cb(null, certs.beta.public);
      else cb();
    },
    store: {
      type: 'encrypted',
      secret: 'blah'
    }
  });

  var next = function(err) {
    throw (err || new Error('`next` fn should not be called'));
  };

  var resetAccessToken = function(cb) {
    req = {
      body: {assertion: jwt.encode({iss: 'alpha@adslot.com'}, certs.alpha.private, 'RS256')}
    };

    var send = function(body) {
      accessToken = body.access_token;
      cb()
    };

    mw.token(req, {send: send}, next);
  };

  beforeEach(resetAccessToken);


  describe('token()', function() {

    it('should return access_token', function(done) {
      req = {
        body: {assertion: jwt.encode({iss: 'alpha@adslot.com'}, certs.alpha.private, 'RS256')}
      };

      var send = function(body) {
        accessToken = body.access_token;
        assert(/.{50,}/.test(body.access_token)); // IG1i9eWVtwR_tHEA9A8_NGP8tbArru43gVXvPdnlaNNTz
        assert.equal(body.token_type, 'Bearer');
        assert.equal(body.expires_in, 3600);
        done()
      };

      mw.token(req, {send: send}, next);
    });

    it('should return "invalid_request" error because of malformed jwt', function(done) {
      req = {
        body: {assertion: 'whateve"r'}
      };

      var res = {
        status: function(code) {
          assert.equal(code, 400);
          return this;
        },
        send: function(body) {
          assert.deepEqual(body, {error: 'invalid_request', error_description: 'JWT cannot be decoded'});
          done()
        }
      };

      mw.token(req, res, next);
    });


    it('should return "invalid_client" error because of unknown client id', function(done) {
      req = {
        body: {assertion: jwt.encode({iss: 'kraken@adslot.com'}, certs.alpha.private, 'RS256')}
      };

      var res = {
        status: function(code) {
          assert.equal(code, 401);
          return this;
        },
        send: function(body) {
          assert.deepEqual(body, {error: 'invalid_client', error_description: 'Unknown client'});
          done()
        }
      };

      mw.token(req, res, next);
    });

    it('should return "invalid_client" error because of invalid client/cert pair', function(done) {
      req = {
        body: {assertion: jwt.encode({iss: 'beta@adslot.com'}, certs.alpha.private, 'RS256')}
      };

      var res = {
        status: function(code) {
          assert.equal(code, 401);
          return this;
        },
        send: function(body) {
          assert.deepEqual(body, {error: 'invalid_client', error_description: 'Client authentication failed'});
          done()
        }
      };

      mw.token(req, res, next);
    });
  });


  describe('check()', function() {

    var makeRes = function(sendStatus) {
      return {
        sendStatus: sendStatus,
        headers: {},
        set: function(k, v) { this.headers[k] = v; }
      };
    };

    it('should call `next` if token is fresh and valid (query params)', function(done) {
      var req = {query: {access_token: accessToken}};
      mw.check(req, {}, function(err) {
        if (err) return done(err);
        assert.equal(req.session.id, 1);
        assert.equal(req.session.iss, 'alpha@adslot.com');
        done()
      });
    });

    it('should call `next` if token is fresh and valid (post body)', function(done) {
      var req = {query: {}, body: {access_token: accessToken}};
      mw.check(req, {}, done);
    });

    it('should call `next` if token is fresh and valid (header)', function(done) {
      var req = {query: {}, body: {}, headers: {authorization: 'Bearer ' + accessToken}};
      mw.check(req, {}, done);
    });

    it('should return "invalid_token" error if no access_token provided', function(done) {
      var req = {query: {}, body: {}, headers: {}};
      var res = makeRes(function(code) {
        assert.equal(code, 401);
        assert.deepEqual(this.headers, {
          'WWW-Authenticate': 'Bearer realm="example", error="invalid_token", ' +
            'error_description="Access token is not present"'
        })
        done();
      })
      mw.check(req, res, next);
    });

    it('should return "invalid_token" error if access_token unknown/malformed', function(done) {
      var req = {query: {access_token: 'kraken-over-the-wire'}, body: {}, headers: {}};
      var res = makeRes(function(code) {
        assert.equal(code, 401);
        assert.deepEqual(this.headers, {
          'WWW-Authenticate': 'Bearer realm="example", error="invalid_token", error_description="Unknown access token"'
        })
        done();
      });
      mw.check(req, res, next);
    });

    it('should return "invalid_token" error if access_token expired', function(done) {
      var tmp = mw.options.ttl;
      mw.options.ttl = -1;

      resetAccessToken(function() {
        var req = {query: {access_token: accessToken}};
        var res = makeRes(function(code) {
          assert.equal(code, 401);
          assert.deepEqual(this.headers, {
            'WWW-Authenticate': 'Bearer realm="example", error="invalid_token", error_description="Access token expired"'
          })
          mw.options.ttl = tmp; // restore original value
          done();
        })
        mw.check(req, res, next);
      });
    });

  });

});
