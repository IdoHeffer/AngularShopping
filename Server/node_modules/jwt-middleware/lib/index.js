var crypto = require('crypto'),
  jws = require('jws'),
  assert = require('assert'),
  store = require('./store');


function Middleware(options) {
  assert(options.getKey, 'options.getKey should be provided');
  assert(options.store, 'options.store should be provided');
  options.ttl = options.ttl || 3600;
  options.debug = options.debug || function() {};

  this.options = options;
  this.store = store(options.store); // store factory
}


Middleware.prototype.token = function(req, res, next) {
  var signature = req.body.assertion,
    self = this;

  // refer to http://tools.ietf.org/html/rfc6749#section-5.2 for more details
  var error = function(msg, descr, code) {
    self.options.debug({error: msg, context: {descr: descr}});
    res.status(code || 400).send({error: msg, error_description: descr});
  };

  try {
    var decoded = jws.decode(signature);
  } catch (e) {
    self.options.debug({error: e, context: {signature: signature}});
  }

  if (!decoded)
    return error('invalid_request', 'JWT cannot be decoded');

  self.options.getKey(decoded.payload, function(err, key, session) {
    if (!key)
      return error('invalid_client', 'Unknown client', 401);

    try {
      assert(decoded.header.alg, 'JWT header does not contain `alg` field');
      var verified = jws.verify(signature, decoded.header.alg, key);
    } catch (e) {
      self.options.debug({error: e, context: {signature: signature, key: key}});
    }

    if (!verified)
      return error('invalid_client', 'Client authentication failed', 401);

    meta = decoded.payload;
    meta.exp = ~~(Date.now() / 1000) + self.options.ttl;

    if (session)
      for (var key in session)
        meta[key] = session[key];

    self.store.make(meta, function(err, token) {
      if (err) return next(err);

      res.send({access_token: token, token_type: 'Bearer', expires_in: self.options.ttl});
    });
  });
};


Middleware.prototype.check = function(req, res, next) {
  var bearerRegexp = /^Bearer\s(\S+)/,
    match = null,
    self = this;

  var accessToken = (req.query ? req.query.access_token : null) ||
                    (req.body ? req.body.access_token : null);

  if (!accessToken && req.headers.authorization && (match = req.headers.authorization.match(bearerRegexp)))
    accessToken = match[1];

  var error = function(msg, descr) {
    self.options.debug({error: msg, context: {descr: descr}});

    // Refer to http://tools.ietf.org/html/rfc6750#section-3 for more details
    res.set('WWW-Authenticate', 'Bearer realm="example", error="' + msg + '", error_description="' + descr + '"');
    res.sendStatus(401);
  }

  if (!accessToken)
    return error('invalid_token', 'Access token is not present');

  self.store.retrieve(accessToken, function(err, meta) {
    if (err) return next(err);

    if (!meta)
      return error('invalid_token', 'Unknown access token');

    if (Date.now() > meta.exp * 1000)
      return error('invalid_token', 'Access token expired');

    req.session = meta;

    next();
  });
};


module.exports = Middleware;
